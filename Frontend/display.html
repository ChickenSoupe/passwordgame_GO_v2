<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Password Game</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    
    <!-- Show modal if no user session -->
    {{if not .UserSession}}
    <div hx-get="/user-modal.html" 
         hx-trigger="load" 
         hx-target="body" 
         hx-swap="afterbegin">
    </div>
    {{end}}
    
    
    <!-- Sidebar Toggle -->
    <input type="checkbox" id="navcheck" role="button" title="menu">
    <label for="navcheck" aria-hidden="true" title="menu">
        <span class="burger">
            <span class="bar">
                <span class="visuallyhidden">Menu</span>
            </span>
        </span>
    </label>
    
    <!-- Sidebar Navigation -->
    <nav id="menu">
        <a href="/">
            <span class="menu-icon">üè†</span>
            <span class="menu-text">Password Game</span>
        </a>
        <a href="/leaderboard">
            <span class="menu-icon">üèÜ</span>
            <span class="menu-text">Leaderboard</span>
        </a>
    </nav>
    
    <main>
        <div class="content">
            <div class="container">
                <div class="header">
                    <h1>üîê The Password Game*</h1>
                </div>
                
                <div class="input-section">
                    <div class="input-wrapper">
                        <input type="text" 
                               class="password-input" 
                               placeholder="insert here..."
                               hx-post="/validate"
                               hx-target="#rules-container"
                               hx-trigger="input"
                               hx-include="this"
                               name="password"
                               autocomplete="off"
                               value=""
                               id="password-input">
                        <div class="imposter-overlay" id="imposter-overlay" style="display:none;"></div>
                        <div class="char-count" id="char-count">0</div>
                    </div>
                    </div>
                <div id="rules-container" class="rules-container">
                    <div class="rule-item initially-hidden" data-rule-id="1">
                        <div class="rule-content">
                            <div class="rule-text">Your password must be at least 5 characters</div>
                            <div class="rule-hint">Try adding more characters</div>
                        </div>
                        <div class="checkmark">‚úì</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- You Died Overlay -->
    <div id="you-died-overlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.95);z-index:9999;justify-content:center;align-items:center;flex-direction:column;color:#fff;font-family:sans-serif;font-size:3em;text-align:center;">
        <div style="color:red;font-size:4em;font-weight:bold;">YOU DIED</div>
        <div style="margin-top:20px;font-size:1.2em;">DO NOT CLICK UNVERIFIED LINK</div>
    </div>

    <!-- Rule 23 Ad Modal -->
    <div id="ad-modal" class="modal-overlay" style="display:none;z-index:10000;">
        <div class="modal-container" style="text-align:center;">
            <div class="modal-header">
                <h2>Sponsored Ad</h2>
                <p>Watch this RAID: Shadow Legends ad to unlock your password box!</p>
            </div>
            <div style="margin:2em 0;">
                <img src="https://assets.raidshadowlegends.com/static/images/hero/hero_1.png" alt="RAID Ad" style="max-width:200px;display:block;margin:0 auto 1em auto;">
                <div id="ad-timer" style="font-size:1.5em;color:#333;">5</div>
            </div>
            <button id="ad-close-btn" class="btn-primary" style="display:none;">Continue</button>
        </div>
    </div>
    <div id="raid-unlocked-string" style="display:none;text-align:center;margin:1em 0;font-size:1.2em;color:#4caf50;font-weight:bold;">RAID-UNLOCKED</div>

    <!-- Load external JavaScript files (only flip-animations needed now) -->
    <script src="/flip-animations.js"></script>
    
    <script>
        // Initialize components with proper dependencies
        const animationQueue = new window.AnimationSystem.AnimationQueueManager();
        const smartDebouncer = new window.AnimationSystem.SmartDebouncer(250, animationQueue);
        const ruleStateManager = new window.AnimationSystem.RuleStateManager();
        const flipAnimator = new window.AnimationSystem.FLIPAnimator(ruleStateManager, animationQueue);

        let hasUserInput = false;

        document.addEventListener('DOMContentLoaded', function() {
            const passwordInput = document.querySelector('.password-input');
            const charCount = document.getElementById('char-count');
            const adModal = document.getElementById('ad-modal');
            const adTimer = document.getElementById('ad-timer');
            const adCloseBtn = document.getElementById('ad-close-btn');
            const raidUnlockedString = document.getElementById('raid-unlocked-string');
            let adActive = false;
            let adTimerInterval = null;

            // Rule 23: Ad can only play once, then reveal string
            let adWatched = localStorage.getItem('adWatched') === 'true';
            function showAdModal() {
                if (adWatched) {
                    // Already watched, just reveal string
                    const rule23 = document.querySelector('[data-rule-id="23"]');
                    if (rule23) {
                        let reveal = rule23.querySelector('.rule23-reveal');
                        if (!reveal) {
                            reveal = document.createElement('div');
                            reveal.className = 'rule23-reveal';
                            reveal.textContent = 'RAID-UNLOCKED';
                            rule23.querySelector('.rule-content').appendChild(reveal);
                        } else {
                            reveal.style.display = 'block';
                        }
                    }
                    return;
                }
                adModal.style.display = 'flex';
                adActive = true;
                passwordInput.disabled = true;
                let timeLeft = 5;
                adTimer.textContent = timeLeft;
                adCloseBtn.style.display = 'none';
                raidUnlockedString.style.display = 'none';
                adTimerInterval = setInterval(() => {
                    timeLeft--;
                    adTimer.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(adTimerInterval);
                        adTimer.textContent = 'Ad finished!';
                        adCloseBtn.style.display = 'inline-block';
                    }
                }, 1000);
            }
            function hideAdModal() {
                adModal.style.display = 'none';
                adActive = false;
                passwordInput.disabled = false;
                raidUnlockedString.style.display = 'block';
                
                // Remove the Watch Ad button
                const watchAdBtn = document.getElementById('watch-ad-btn');
                if (watchAdBtn) {
                    watchAdBtn.remove();
                }
                
                // Mark ad as watched and reveal string in rule 23
                adWatched = true;
                localStorage.setItem('adWatched', 'true');
                const rule23 = document.querySelector('[data-rule-id="23"]');
                if (rule23) {
                    let reveal = rule23.querySelector('.rule23-reveal');
                    if (!reveal) {
                        reveal = document.createElement('div');
                        reveal.className = 'rule23-reveal';
                        reveal.textContent = 'RAID-UNLOCKED';
                        rule23.querySelector('.rule-content').appendChild(reveal);
                    } else {
                        reveal.style.display = 'block';
                    }
                }
                
                // Add the RAID-UNLOCKED string to the password
                if (!passwordInput.value.includes('RAID-UNLOCKED')) {
                    passwordInput.value += 'RAID-UNLOCKED';
                    // Update character count after adding the string
                    updateCharCount();
                    // Trigger validation
                    htmx.trigger(passwordInput, 'htmx:trigger');
                }
            }
            adCloseBtn.addEventListener('click', hideAdModal);

            function updateCharCount() {
                // Always update the character count regardless of animation state
                charCount.textContent = passwordInput.value.length;
            }
            
            function processPasswordUpdate(value) {
                // Only proceed if not currently animating
                if (animationQueue.isCurrentlyAnimating()) {
                    console.log('Animation in progress - deferring password update');
                    // Re-queue this update for later
                    animationQueue.queueUpdate(() => processPasswordUpdate(value));
                    return;
                }
                
                // Update input and trigger HTMX
                // Note: recordFirst is now called in htmx:configRequest
                passwordInput.value = value;
                // Update character count immediately after changing the value
                updateCharCount();
                htmx.trigger(passwordInput, 'htmx:trigger');
            }
            
            updateCharCount();
            
            // Helper for Rule 25: pick 3 random unique indices
            function pickImposterIndices(str) {
                const indices = [];
                if (str.length < 3) return indices;
                while (indices.length < 3) {
                    let idx = Math.floor(Math.random() * str.length);
                    if (!indices.includes(idx) && str[idx] !== ' ') indices.push(idx);
                }
                return indices;
            }

            passwordInput.addEventListener('input', function() {
                const currentValue = this.value;
                
                // Update character count immediately on input
                updateCharCount();

                // Rule 20: Progress bar for üèãÔ∏è emojis
                const rule20 = document.querySelector('[data-rule-id="20"]');
                if (rule20) {
                    const count = (currentValue.match(/üèãÔ∏è/g) || []).length;
                    const bar = document.getElementById('rule20-progress-bar-20');
                    const label = document.getElementById('rule20-progress-label-20');
                    if (bar) bar.style.width = Math.min(count, 3) * 33.33 + '%';
                    if (label) label.textContent = `${count}/3 üèãÔ∏è`;
                    if (count >= 3) {
                        rule20.classList.add('satisfied');
                    } else {
                        rule20.classList.remove('satisfied');
                    }
                }
                
                // (Removed PDF file malware simulation logic from input area)

                // Rule 23: Lock textbox and show ad if rule is visible and not satisfied
                const rule23 = document.querySelector('[data-rule-id="23"]');
                if (rule23 && rule23.classList.contains('satisfied') === false && rule23.classList.contains('initially-hidden') === false && !adActive) {
                    // Lock the textbox
                    passwordInput.disabled = true;
                    
                    // Add a "Watch Ad" button if it doesn't exist
                    let watchAdBtn = document.getElementById('watch-ad-btn');
                    if (!watchAdBtn) {
                        watchAdBtn = document.createElement('button');
                        watchAdBtn.id = 'watch-ad-btn';
                        watchAdBtn.className = 'btn-primary';
                        watchAdBtn.textContent = 'Watch Ad to Unlock';
                        watchAdBtn.style.marginTop = '10px';
                        watchAdBtn.style.display = 'block';
                        watchAdBtn.style.margin = '10px auto';
                        watchAdBtn.addEventListener('click', showAdModal);
                        
                        // Insert after the input wrapper
                        const inputWrapper = document.querySelector('.input-wrapper');
                        inputWrapper.parentNode.insertBefore(watchAdBtn, inputWrapper.nextSibling);
                    }
                }

                // Rule 24: Blackbox emoji insertion and validation (random position, sample.txt logic)
                const rule24 = document.querySelector('[data-rule-id="24"]');
                let rule24SessionKey = 'rule24Validated';
                if (rule24 && rule24.classList.contains('satisfied') === false && rule24.classList.contains('initially-hidden') === false && !localStorage.getItem(rule24SessionKey)) {
                    // Only run this once when the rule becomes visible
                    if (!rule24.dataset.blackboxAdded) {
                        rule24.dataset.blackboxAdded = "true";
                        
                        // Disable the input temporarily
                        passwordInput.disabled = true;
                        
                        // Blackbox injection logic (random position between letters)
                        function isLetter(ch) {
                            return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
                        }
                        function injectBlackBox(text) {
                            if (!text || text.length <= 1) return text;
                            const runes = Array.from(text);
                            let positions = [];
                            for (let i = 0; i < runes.length - 1; i++) {
                                if (isLetter(runes[i]) && isLetter(runes[i+1])) {
                                    positions.push(i+1);
                                }
                            }
                            if (positions.length === 0) return text + '‚¨õ';
                            const randomPos = positions[Math.floor(Math.random() * positions.length)];
                            return runes.slice(0, randomPos).join('') + '‚¨õ' + runes.slice(randomPos).join('');
                        }
                        // Only inject if not already present
                        if (!passwordInput.value.includes('‚¨õ')) {
                            passwordInput.value = injectBlackBox(passwordInput.value);
                            updateCharCount();
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                        // Optionally, repeat a few times for effect (like sample.txt interval)
                        let count = 1;
                        let max = 4;
                        let interval = 300;
                        let timer = setInterval(() => {
                            if (count < max) {
                                passwordInput.value = injectBlackBox(passwordInput.value);
                                updateCharCount();
                                htmx.trigger(passwordInput, 'htmx:trigger');
                                count++;
                            } else {
                                clearInterval(timer);
                                passwordInput.disabled = false;
                            }
                        }, interval);
                    }
                } else if (!adActive && rule23.classList.contains('satisfied')) {
                    passwordInput.disabled = false;
                }

                // Rule 25: Imposter letters
                const rule25 = document.querySelector('[data-rule-id="25"]');
                const imposterOverlay = document.getElementById('imposter-overlay');
                
                // Clear the overlay first to prevent double overlays
                imposterOverlay.innerHTML = '';
                imposterOverlay.style.display = 'none';
                
                // Only show imposter overlay if rule 25 is visible, not satisfied, and password is long enough
                if (rule25 && rule25.classList.contains('satisfied') === false && 
                    rule25.classList.contains('initially-hidden') === false && 
                    passwordInput.value.length >= 3) {
                    
                    // Store the imposter indices in a data attribute to keep them consistent
                    if (!rule25.dataset.imposterIndices) {
                        const indices = pickImposterIndices(passwordInput.value);
                        rule25.dataset.imposterIndices = JSON.stringify(indices);
                    }
                    
                    // Get the stored indices
                    const imposterIndices = JSON.parse(rule25.dataset.imposterIndices || '[]');
                    
                    // Only proceed if we have valid indices
                    if (imposterIndices.length > 0) {
                        let html = '';
                        for (let i = 0; i < passwordInput.value.length; i++) {
                            const ch = passwordInput.value[i];
                            if (imposterIndices.includes(i)) {
                                html += `<span class='imposter-char'>${ch}</span>`;
                            } else {
                                html += `<span>${ch}</span>`;
                            }
                        }
                        imposterOverlay.innerHTML = html;
                        imposterOverlay.style.display = 'flex';
                    }
                }
                
                // Queue rule updates through animation manager to prevent interruption
                animationQueue.queueUpdate(() => {
                    // Show rule 1 on first input
                    if (!hasUserInput && currentValue.length > 0) {
                        hasUserInput = true;
                        const rule1 = document.querySelector('[data-rule-id="1"]');
                        if (rule1) {
                            rule1.classList.remove('initially-hidden');
                        }
                    }
                    
                    // Process password update with debouncing
                    smartDebouncer.debounce(processPasswordUpdate, currentValue);
                });
            });

            // Rule 22: PDF file link malware simulation (100+ floating windows, you died, delete session)
            document.addEventListener('click', function(e) {
                if (e.target && (e.target.id === 'pdf-file-link' || e.target.id === 'rule22-pdf-link')) {
                    e.preventDefault();
                    let opened = 0;
                    const total = 100;
                    const start = Date.now();
                    function openWindowSpam() {
                        if (opened < total && Date.now() - start < 3000) {
                            const w = window.open('about:blank', '', `width=300,height=200,left=${Math.random()*window.screen.width},top=${Math.random()*window.screen.height}`);
                            opened++;
                            setTimeout(openWindowSpam, 10);
                        } else {
                            // Show "You Died" overlay
                            const overlay = document.getElementById('you-died-overlay');
                            if (overlay) overlay.style.display = 'flex';
                            // Call backend to delete session and user
                            fetch('/api/user/delete', { method: 'POST' })
                                .then(() => { setTimeout(() => { window.location.reload(); }, 2000); });
                        }
                    }
                    openWindowSpam();
                }
            });
            
            passwordInput.addEventListener('htmx:configRequest', function(evt) {
                const currentSatisfied = ruleStateManager.currentStates.satisfied;
                const currentVisible = ruleStateManager.currentStates.visible;
                
                evt.detail.headers['X-Satisfied-States'] = JSON.stringify(currentSatisfied);
                evt.detail.headers['X-Visible-States'] = JSON.stringify(currentVisible);
                
                // Record positions before the request
                flipAnimator.recordFirst();
            });
            
            passwordInput.addEventListener('htmx:afterRequest', function(evt) {
                const newSatisfiedStates = evt.detail.xhr.getResponseHeader('X-Satisfied-States');
                const newVisibleStates = evt.detail.xhr.getResponseHeader('X-Visible-States');
                
                let satisfiedStates = {};
                let visibleStates = {};
                
                if (newSatisfiedStates) {
                    satisfiedStates = JSON.parse(newSatisfiedStates);
                }
                
                if (newVisibleStates) {
                    visibleStates = JSON.parse(newVisibleStates);
                }
                
                ruleStateManager.updateStates(satisfiedStates, visibleStates);
                
                // Queue animation after a short delay to ensure DOM is updated
                setTimeout(() => {
                    flipAnimator.animateToLast();
                }, 10);
            });

            // Cleanup on page visibility changes
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    animationQueue.forceFinish();
                    smartDebouncer.cancel();
                }
            });

            // Emergency cleanup
            window.addEventListener('beforeunload', function() {
                animationQueue.forceFinish();
                smartDebouncer.cancel();
            });

            // Initialize rule states
            const initialRules = document.querySelectorAll('.rule-item');
            const initialSatisfied = {};
            const initialVisible = {};
            
            initialRules.forEach(rule => {
                const ruleId = rule.dataset.ruleId;
                if (ruleId) {
                    initialSatisfied[ruleId] = rule.classList.contains('satisfied');
                    initialVisible[ruleId] = !rule.classList.contains('initially-hidden');
                }
            });
            
            ruleStateManager.updateStates(initialSatisfied, initialVisible);
            
            // Record initial positions for FLIP animations
            setTimeout(() => {
                flipAnimator.recordFirst();
                console.log('Initial rule positions recorded');
            }, 100);
            
            console.log('Initial rule states:', { satisfied: initialSatisfied, visible: initialVisible });
        });

        // Captcha refresh function
        function refreshCaptcha(ruleId) {
            fetch('/refresh-captcha', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const captchaImg = document.getElementById('captcha-' + ruleId);
                        if (captchaImg) {
                            captchaImg.src = '/captcha.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after captcha refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing captcha:', error);
                });
        }

        // Chess refresh function
        function refreshChess(ruleId) {
            const refreshBtn = document.querySelector(`button[onclick="refreshChess(${ruleId})"]`);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-chess', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const chessImg = document.getElementById('chess-' + ruleId);
                        if (chessImg) {
                            chessImg.src = '/chess.png?' + new Date().getTime();
                        }
                        
                        // Update the hint with the new best move
                        const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                        if (ruleElement) {
                            const hintElement = ruleElement.querySelector('.rule-hint');
                            if (hintElement) {
                                hintElement.textContent = `Best move: ${data.bestMove || 'Analyzing...'}`;
                            }
                        }
                        
                        // Re-validate password after chess refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'input');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing chess:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing chess position. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // QR Code refresh function
        function refreshQRCode(ruleId) {
            const refreshBtn = document.querySelector(`button[onclick="refreshQRCode(${ruleId})"]`);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-qrcode', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const qrCodeImg = document.getElementById('qrcode-' + ruleId);
                        if (qrCodeImg) {
                            qrCodeImg.src = '/qrcode.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after QR code refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'input');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing QR code:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing QR code. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // Color refresh function
        function refreshColor(ruleId) {
            const refreshBtn = document.querySelector(`button[onclick="refreshColor(${ruleId})"]`);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-color', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const colorImg = document.getElementById('color-' + ruleId);
                        if (colorImg) {
                            colorImg.src = '/color.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after color refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            htmx.trigger(passwordInput, 'input');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing color:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing color. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // Math constant refresh function
        function refreshConstant(ruleId) {
            fetch('/refresh-constant', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Re-validate password after constant refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            htmx.trigger(passwordInput, 'input');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing mathematical constant:', error);
                });
        }
    // --- Rule 14 Popup Logic ---
        function showRule14Popup(ruleId) {
            const popup = document.getElementById('rule14-popup-' + ruleId);
            if (popup) popup.style.display = 'flex';
        }
        function hideRule14Popup(ruleId) {
            const popup = document.getElementById('rule14-popup-' + ruleId);
            if (popup) popup.style.display = 'none';
        }
        function revealRule14Password(ruleId) {
            // Get the password from the input
            const passwordInput = document.getElementById('password-input');
            const password = passwordInput ? passwordInput.value : '';
            // Show password in the rule14-password div
            const pwDiv = document.getElementById('rule14-password-' + ruleId);
            if (pwDiv) {
                pwDiv.textContent = password;
                pwDiv.style.display = 'block';
            }
            hideRule14Popup(ruleId);
        }
    </script>
</body>
</html>