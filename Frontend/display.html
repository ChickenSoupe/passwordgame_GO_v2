<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Password Game</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
     <link rel="stylesheet" href="/style.css">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” The Password Game*</h1>
        </div>
        
        <div class="input-section">
            <div class="input-wrapper">
                <input type="text" 
                       class="password-input" 
                       placeholder="insert here..."
                       hx-post="/validate"
                       hx-target="#rules-container"
                       hx-trigger="input"
                       hx-include="this"
                       name="password"
                       autocomplete="off"
                       value=""
                       id="password-input">
                <div class="char-count" id="char-count">0</div>
            </div>
        </div>
        
        <div id="rules-container" class="rules-container">
            <!-- Rule 1 initially hidden -->
            <div class="rule-item initially-hidden" data-rule-id="1">
                <div class="rule-number">1</div>
                <div class="rule-content">
                    <div class="rule-text">Your password must be at least 5 characters</div>
                    <div class="rule-hint">Try adding more characters</div>
                </div>
                <div class="checkmark">âœ“</div>
            </div>
        </div>
    </div>

    <script>
        // FLIP Animation System
        class FLIPAnimator {
            constructor() {
                this.isAnimating = false;
                this.pendingUpdate = null;
                this.firstStates = new Map();
            }

            recordFirst() {
                const rules = document.querySelectorAll('.rule-item');
                this.firstStates.clear();
                
                rules.forEach(rule => {
                    const rect = rule.getBoundingClientRect();
                    this.firstStates.set(rule.dataset.ruleId, {
                        top: rect.top,
                        left: rect.left,
                        width: rect.width,
                        height: rect.height
                    });
                });
            }

            animateToLast() {
                if (this.firstStates.size === 0) return;

                const rules = document.querySelectorAll('.rule-item');
                const animatingRules = [];

                rules.forEach(rule => {
                    const ruleId = rule.dataset.ruleId;
                    const first = this.firstStates.get(ruleId);
                    
                    if (!first) return; // New rule, no animation needed

                    const last = rule.getBoundingClientRect();
                    const deltaX = first.left - last.left;
                    const deltaY = first.top - last.top;

                    // Only animate if there's significant movement
                    if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1) {
                        // Apply initial transform (First position)
                        rule.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                        rule.style.transition = 'none';
                        
                        // Force reflow
                        rule.offsetHeight;
                        
                        // Add animation class and animate to Last position
                        rule.classList.add('flip-animate');
                        rule.style.transition = 'transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
                        rule.style.transform = 'translate(0, 0)';
                        
                        animatingRules.push(rule);
                    }
                });

                if (animatingRules.length > 0) {
                    this.isAnimating = true;
                    
                    // Clean up after animation completes
                    const cleanup = () => {
                        animatingRules.forEach(rule => {
                            rule.style.transform = '';
                            rule.style.transition = '';
                            rule.classList.remove('flip-animate');
                        });
                        this.isAnimating = false;
                        this.processPendingUpdate();
                    };

                    // Use timeout as fallback and listen for transition end
                    setTimeout(cleanup, 500);
                    
                    animatingRules[0].addEventListener('transitionend', cleanup, { once: true });
                } else {
                    this.processPendingUpdate();
                }
            }

            processPendingUpdate() {
                if (this.pendingUpdate !== null) {
                    htmx.trigger(document.getElementById('password-input'), 'htmx:trigger');
                    this.pendingUpdate = null;
                }
            }

            setPendingUpdate(value) {
                this.pendingUpdate = value;
            }
        }

        // Initialize FLIP animator
        const flipAnimator = new FLIPAnimator();

        // Track state
        let satisfiedStates = {};
        let visibleStates = {};
        let hasUserInput = false;

        document.addEventListener('DOMContentLoaded', function() {
            const passwordInput = document.querySelector('.password-input');
            const charCount = document.getElementById('char-count');
            const rulesContainer = document.getElementById('rules-container');
            
            function updateCharCount() {
                charCount.textContent = passwordInput.value.length;
            }
            
            // Update on page load
            updateCharCount();
            
            // Handle input with FLIP animation
            passwordInput.addEventListener('input', function() {
                updateCharCount();
                
                // Show rule 1 on first input
                if (!hasUserInput && this.value.length > 0) {
                    hasUserInput = true;
                    const rule1 = document.querySelector('[data-rule-id="1"]');
                    if (rule1) {
                        rule1.classList.remove('initially-hidden');
                    }
                }
                
                // If animations are playing, store the pending update
                if (flipAnimator.isAnimating) {
                    flipAnimator.setPendingUpdate(this.value);
                    return;
                }
                
                // Record FIRST state before HTMX update
                flipAnimator.recordFirst();
            });
            
            // Update headers before HTMX request
            passwordInput.addEventListener('htmx:configRequest', function(evt) {
                evt.detail.headers['X-Satisfied-States'] = JSON.stringify(satisfiedStates);
                evt.detail.headers['X-Visible-States'] = JSON.stringify(visibleStates);
            });
            
            // Handle FLIP animation after HTMX response
            passwordInput.addEventListener('htmx:afterRequest', function(evt) {
                const newSatisfiedStates = evt.detail.xhr.getResponseHeader('X-Satisfied-States');
                if (newSatisfiedStates) {
                    satisfiedStates = JSON.parse(newSatisfiedStates);
                }
                
                const newVisibleStates = evt.detail.xhr.getResponseHeader('X-Visible-States');
                if (newVisibleStates) {
                    visibleStates = JSON.parse(newVisibleStates);
                }
                
                // Trigger FLIP animation (LAST and INVERT + PLAY)
                requestAnimationFrame(() => {
                    flipAnimator.animateToLast();
                });
            });
        });
    </script>
</body>
</html>