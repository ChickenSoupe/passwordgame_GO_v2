<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Ultimate Password Game</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <link rel="stylesheet" href="/style.css">
</head>
<body>
    
    <!-- Show modal if no user session -->
    {{if not .UserSession}}
    <div hx-get="/user-modal.html" 
         hx-trigger="load" 
         hx-target="body" 
         hx-swap="afterbegin">
    </div>
    {{end}}
    
    
    <!-- Sidebar Toggle -->
    <input type="checkbox" id="navcheck" role="button" title="menu">
    <label for="navcheck" aria-hidden="true" title="menu">
        <span class="burger">
            <span class="bar">
                <span class="visuallyhidden">Menu</span>
            </span>
        </span>
    </label>
    
    <!-- Sidebar Navigation -->
    <nav id="menu">
        <a href="/">
            <span class="menu-icon">üè†</span>
            <span class="menu-text">Password Game</span>
        </a>
        <a href="/leaderboard">
            <span class="menu-icon">üèÜ</span>
            <span class="menu-text">Leaderboard</span>
        </a>
        <a href="#" id="toggle-hints" class="hint-toggle">
            <span class="menu-icon">üí°</span>
            <span class="menu-text">Toggle Hints</span>
        </a>
    </nav>
    
    <main>
        <div class="content">
            <div class="container">
                <div class="header">
                    <h1>üîê The Password Game*</h1>
                </div>
                
                <div class="input-section">
                    <div class="input-wrapper">
                        <textarea class="password-input" 
                                  placeholder="insert here..."
                                  hx-post="/validate"
                                  hx-target="#rules-container"
                                  hx-trigger="input"
                                  hx-include="this"
                                  name="password"
                                  autocomplete="off"
                                  id="password-input"
                                  rows="1"></textarea>
                        <div class="imposter-overlay" id="imposter-overlay" style="display:none;"></div>
                        <div class="char-count" id="char-count">0</div>
                    </div>
                    </div>
                <div id="rules-container" class="rules-container">
                    <div class="rule-item initially-hidden" data-rule-id="1">
                        <div class="rule-content">
                            <div class="rule-text">Your password must be at least 5 characters</div>
                            <div class="rule-hint">Try adding more characters</div>
                        </div>
                        <div class="checkmark">‚úì</div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- You Died Overlay -->
    <div id="you-died-overlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.95);z-index:9999;justify-content:center;align-items:center;flex-direction:column;color:#fff;font-family:sans-serif;font-size:3em;text-align:center;">
        <div style="color:red;font-size:4em;font-weight:bold;">YOU DIED</div>
        <div style="margin-top:20px;font-size:1.2em;">DO NOT CLICK UNVERIFIED LINK</div>
    </div>

    <!-- Rule 23 Ad Modal -->
    <div id="ad-modal" class="modal-overlay" style="display:none;z-index:10000;">
        <div class="modal-container" style="text-align:center;">
            <div class="modal-header">
                <h2>Sponsored Ad</h2>
                <p>Watch this RAID: Shadow Legends ad to unlock your password box!</p>
            </div>
            <div style="margin:2em 0;">
                <img src="https://assets.raidshadowlegends.com/static/images/hero/hero_1.png" alt="RAID Ad" style="max-width:200px;display:block;margin:0 auto 1em auto;">
                <div id="ad-timer" style="font-size:1.5em;color:#333;">5</div>
            </div>
            <button id="ad-close-btn" class="btn-primary" style="display:none;">Continue</button>
        </div>
    </div>
    <div id="raid-unlocked-string" style="display:none;text-align:center;margin:1em 0;font-size:1.2em;color:#4caf50;font-weight:bold;">RAID-UNLOCKED</div>

    <!-- Success Modal -->
    <div id="success-modal" class="modal-overlay" style="display:none;z-index:10001;">
        <div class="modal-container" style="max-width:600px;text-align:center;">
            <div class="modal-header">
                <h1 style="color:#4caf50;font-size:2.5em;margin:0;text-shadow:2px 2px 4px rgba(0,0,0,0.3);">üéâ Congratulations! üéâ</h1>
                <p style="font-size:1.3em;margin:1em 0;color:#333;">You've successfully completed all password rules!</p>
            </div>
            <div style="margin:2em 0;text-align:left;background:#f8f9fa;padding:2em;border-radius:8px;border-left:4px solid #4caf50;">
                <h2 style="color:#2e7d32;margin-top:0;text-align:center;">üîê Password Security Tips</h2>
                <ul style="line-height:1.6;color:#333;margin:1em 0;padding-left:1.5em;">
                    <li><strong>Use unique passwords</strong> for each account - never reuse passwords across multiple sites</li>
                    <li><strong>Enable two-factor authentication (2FA)</strong> wherever possible for an extra layer of security</li>
                    <li><strong>Use a password manager</strong> to generate and store strong, unique passwords securely</li>
                    <li><strong>Avoid personal information</strong> like birthdays, names, or addresses in your passwords</li>
                    <li><strong>Keep passwords private</strong> - never share them via email, text, or unsecured channels</li>
                    <li><strong>Update passwords regularly</strong> especially if you suspect they may have been compromised</li>
                    <li><strong>Be cautious of phishing</strong> - always verify the authenticity of login pages</li>
                    <li><strong>Use secure networks</strong> - avoid entering passwords on public Wi-Fi when possible</li>
                </ul>
            </div>
            <div style="margin:2em 0;padding:1.5em;background:#e8f5e8;border-radius:8px;">
                <h3 style="color:#2e7d32;margin-top:0;">üèÜ Achievement Unlocked!</h3>
                <p style="margin:0.5em 0;color:#333;">You've mastered the art of password creation. Remember, while this game uses extreme rules for fun, real passwords should be:</p>
                <div style="display:flex;justify-content:space-around;margin:1em 0;flex-wrap:wrap;">
                    <span style="background:#4caf50;color:white;padding:0.5em 1em;border-radius:20px;margin:0.25em;">Long</span>
                    <span style="background:#4caf50;color:white;padding:0.5em 1em;border-radius:20px;margin:0.25em;">Random</span>
                    <span style="background:#4caf50;color:white;padding:0.5em 1em;border-radius:20px;margin:0.25em;">Unique</span>
                </div>
            </div>
            <div style="margin:2em 0;">
                <button id="success-close-btn" class="btn-primary" style="background:#4caf50;font-size:1.2em;padding:1em 2em;border:none;border-radius:5px;cursor:pointer;">
                    View Leaderboard
                </button>
                <button id="success-restart-btn" class="btn-secondary" style="background:#666;color:white;font-size:1.2em;padding:1em 2em;border:none;border-radius:5px;cursor:pointer;margin-left:1em;">
                    Play Again
                </button>
            </div>
        </div>
    </div>

    <!-- Load external JavaScript files (only flip-animations needed now) -->
    <script src="/flip-animations.js"></script>
    
    <script>
        // Toggle hints functionality
        document.getElementById('toggle-hints').addEventListener('click', function(e) {
            e.preventDefault();
            
            // Toggle hints via API
            fetch('/api/toggle-hints', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
            })
            .then(response => response.json())
            .then(data => {
                // Update the UI to reflect the new state
                const hintElements = document.querySelectorAll('.rule-hint');
                hintElements.forEach(hint => {
                    hint.style.display = data.showHints ? 'block' : 'none';
                });
                
                // Update the button text
                const toggleBtn = document.getElementById('toggle-hints');
                const icon = toggleBtn.querySelector('.menu-icon');
                const text = toggleBtn.querySelector('.menu-text');
                
                if (data.showHints) {
                    icon.textContent = 'üí°';
                    text.textContent = 'Hide Hints';
                } else {
                    icon.textContent = 'üîá';
                    text.textContent = 'Show Hints';
                }
                
                // Show a brief notification
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.textContent = data.showHints ? 'Hints enabled' : 'Hints disabled';
                document.body.appendChild(notification);
                
                // Remove notification after 2 seconds
                setTimeout(() => {
                    notification.remove();
                }, 2000);
            })
            .catch(error => {
                console.error('Error toggling hints:', error);
            });
        });

        // Initialize components with proper dependencies
        const animationQueue = new window.AnimationSystem.AnimationQueueManager();
        const smartDebouncer = new window.AnimationSystem.SmartDebouncer(250, animationQueue);
        const ruleStateManager = new window.AnimationSystem.RuleStateManager();
        const flipAnimator = new window.AnimationSystem.FLIPAnimator(ruleStateManager, animationQueue);

        let hasUserInput = false;

        document.addEventListener('DOMContentLoaded', function() {
            const passwordInput = document.querySelector('.password-input');
            const charCount = document.getElementById('char-count');
            const adModal = document.getElementById('ad-modal');
            const adTimer = document.getElementById('ad-timer');
            const adCloseBtn = document.getElementById('ad-close-btn');
            const raidUnlockedString = document.getElementById('raid-unlocked-string');
            let adActive = false;
            let adTimerInterval = null;
            
            // Success modal elements
            const successModal = document.getElementById('success-modal');
            const successCloseBtn = document.getElementById('success-close-btn');
            const successRestartBtn = document.getElementById('success-restart-btn');
            let gameCompleted = false;

            // Rule 23: Ad can only play once, then reveal string
            let adWatched = localStorage.getItem('adWatched') === 'true';
            function showAdModal() {
                if (adWatched) {
                    // Already watched, just reveal string
                    const rule23 = document.querySelector('[data-rule-id="23"]');
                    if (rule23) {
                        let reveal = rule23.querySelector('.rule23-reveal');
                        if (!reveal) {
                            reveal = document.createElement('div');
                            reveal.className = 'rule23-reveal';
                            reveal.textContent = 'RAID-UNLOCKED';
                            rule23.querySelector('.rule-content').appendChild(reveal);
                        } else {
                            reveal.style.display = 'block';
                        }
                    }
                    return;
                }
                adModal.style.display = 'flex';
                adActive = true;
                passwordInput.disabled = true;
                let timeLeft = 5;
                adTimer.textContent = timeLeft;
                adCloseBtn.style.display = 'none';
                raidUnlockedString.style.display = 'none';
                adTimerInterval = setInterval(() => {
                    timeLeft--;
                    adTimer.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(adTimerInterval);
                        adTimer.textContent = 'Ad finished!';
                        adCloseBtn.style.display = 'inline-block';
                    }
                }, 1000);
            }
            function hideAdModal() {
                adModal.style.display = 'none';
                adActive = false;
                passwordInput.disabled = false;
                raidUnlockedString.style.display = 'block';
                
                // Remove the Watch Ad button
                const watchAdBtn = document.getElementById('watch-ad-btn');
                if (watchAdBtn) {
                    watchAdBtn.remove();
                }
                
                // Mark ad as watched and reveal string in rule 23
                adWatched = true;
                localStorage.setItem('adWatched', 'true');
                const rule23 = document.querySelector('[data-rule-id="23"]');
                if (rule23) {
                    let reveal = rule23.querySelector('.rule23-reveal');
                    if (!reveal) {
                        reveal = document.createElement('div');
                        reveal.className = 'rule23-reveal';
                        reveal.textContent = 'RAID-UNLOCKED';
                        rule23.querySelector('.rule-content').appendChild(reveal);
                    } else {
                        reveal.style.display = 'block';
                    }
                }
                
                // Add the RAID-UNLOCKED string to the password
                if (!passwordInput.value.includes('RAID-UNLOCKED')) {
                    passwordInput.value += 'RAID-UNLOCKED';
                    // Update character count after adding the string
                    updateCharCount();
                    // Auto-resize textarea after adding content
                    autoResizeTextarea();
                    // Trigger validation
                    htmx.trigger(passwordInput, 'htmx:trigger');
                }
            }
            adCloseBtn.addEventListener('click', hideAdModal);
            
            // Success modal functions
            function checkAllRulesSatisfied() {
                if (gameCompleted) return; // Prevent multiple triggers
                
                // Get all visible rules in the current difficulty
                const visibleRules = document.querySelectorAll('.rule-item:not(.initially-hidden)');
                const satisfiedRules = document.querySelectorAll('.rule-item:not(.initially-hidden).satisfied');
                
                console.log(`Checking rules: ${satisfiedRules.length}/${visibleRules.length} satisfied`);
                
                // Check if all visible rules are satisfied
                if (visibleRules.length > 0 && satisfiedRules.length === visibleRules.length) {
                    gameCompleted = true;
                    console.log('All rules satisfied! Showing success modal...');
                    
                    // Small delay to ensure any animations finish
                    setTimeout(() => {
                        successModal.style.display = 'flex';
                        // Disable password input
                        passwordInput.disabled = true;
                        
                        // Add celebration effect
                        successModal.style.animation = 'fadeIn 0.5s ease-in-out';
                        
                        // Optional: Send completion event to backend
                        fetch('/api/game/complete', { 
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ 
                                password: passwordInput.value,
                                completedAt: new Date().toISOString() 
                            })
                        }).catch(err => console.log('Failed to log completion:', err));
                        
                    }, 500);
                }
            }
            
            function hideSuccessModal() {
                successModal.style.display = 'none';
                gameCompleted = false;
                passwordInput.disabled = false;
            }
            
            // Success modal event handlers
            successCloseBtn.addEventListener('click', function() {
                window.location.href = '/leaderboard';
            });
            
            successRestartBtn.addEventListener('click', function() {
                // Clear localStorage and session, then reload page for fresh start
                localStorage.clear();
                
                // Call the clear session endpoint
                fetch('/api/user/clear-session', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                })
                .then(response => {
                    if (response.ok) {
                        // Redirect to root which will show the welcome modal
                        window.location.href = '/';
                    } else {
                        console.error('Failed to clear session');
                        // Fallback: still redirect to home
                        window.location.href = '/';
                    }
                })
                .catch(err => {
                    console.error('Error clearing session:', err);
                    // Fallback: still redirect to home
                    window.location.href = '/';
                });
            });

            function updateCharCount() {
                // Always update the character count regardless of animation state
                charCount.textContent = passwordInput.value.length;
            }
            
            function autoResizeTextarea() {
                // Reset height to auto to get the correct scrollHeight
                passwordInput.style.height = 'auto';
                
                // Calculate the new height based on content
                const scrollHeight = passwordInput.scrollHeight;
                const minHeight = 56; // Match CSS min-height
                const maxHeight = 300; // Match CSS max-height
                
                // Set the new height within bounds
                const newHeight = Math.min(Math.max(scrollHeight, minHeight), maxHeight);
                passwordInput.style.height = newHeight + 'px';
                
                // Show scrollbar if content exceeds max height
                if (scrollHeight > maxHeight) {
                    passwordInput.style.overflow = 'auto';
                } else {
                    passwordInput.style.overflow = 'hidden';
                }
            }
            
            function processPasswordUpdate(value) {
                // Only proceed if not currently animating
                if (animationQueue.isCurrentlyAnimating()) {
                    console.log('Animation in progress - deferring password update');
                    // Re-queue this update for later
                    animationQueue.queueUpdate(() => processPasswordUpdate(value));
                    return;
                }
                
                // Update input and trigger HTMX
                // Note: recordFirst is now called in htmx:configRequest
                passwordInput.value = value;
                // Update character count immediately after changing the value
                updateCharCount();
                // Auto-resize textarea after programmatic value change
                autoResizeTextarea();
                htmx.trigger(passwordInput, 'htmx:trigger');
            }
            
            updateCharCount();
            
            // Initialize textarea size
            autoResizeTextarea();
            
            // Helper for Rule 25: pick 3 random unique indices
            function pickImposterIndices(str) {
                const indices = [];
                if (str.length < 3) return indices;
                while (indices.length < 3) {
                    let idx = Math.floor(Math.random() * str.length);
                    if (!indices.includes(idx) && str[idx] !== ' ') indices.push(idx);
                }
                return indices;
            }

            passwordInput.addEventListener('input', function() {
                const currentValue = this.value;
                
                // Update character count immediately on input
                updateCharCount();
                
                // Auto-resize textarea based on content
                autoResizeTextarea();

                // Rule 20: Progress bar for üèãÔ∏è emojis
                const rule20 = document.querySelector('[data-rule-id="20"]');
                if (rule20) {
                    const count = (currentValue.match(/üèãÔ∏è/g) || []).length;
                    const bar = document.getElementById('rule20-progress-bar-20');
                    const label = document.getElementById('rule20-progress-label-20');
                    if (bar) bar.style.width = Math.min(count, 3) * 33.33 + '%';
                    if (label) label.textContent = `${count}/3 üèãÔ∏è`;
                    if (count >= 3) {
                        rule20.classList.add('satisfied');
                    } else {
                        rule20.classList.remove('satisfied');
                    }
                }
                
                // (Removed PDF file malware simulation logic from input area)

                // Rule 23: Lock textbox and show ad if rule is visible and not satisfied
                const rule23 = document.querySelector('[data-rule-id="23"]');
                if (rule23 && rule23.classList.contains('satisfied') === false && rule23.classList.contains('initially-hidden') === false && !adActive) {
                    // Lock the textbox
                    passwordInput.disabled = true;
                    
                    // Add a "Watch Ad" button if it doesn't exist
                    let watchAdBtn = document.getElementById('watch-ad-btn');
                    if (!watchAdBtn) {
                        watchAdBtn = document.createElement('button');
                        watchAdBtn.id = 'watch-ad-btn';
                        watchAdBtn.className = 'btn-primary';
                        watchAdBtn.textContent = 'Watch Ad to Unlock';
                        watchAdBtn.style.marginTop = '10px';
                        watchAdBtn.style.display = 'block';
                        watchAdBtn.style.margin = '10px auto';
                        watchAdBtn.addEventListener('click', showAdModal);
                        
                        // Insert after the input wrapper
                        const inputWrapper = document.querySelector('.input-wrapper');
                        inputWrapper.parentNode.insertBefore(watchAdBtn, inputWrapper.nextSibling);
                    }
                }

                // Rule 24: Blackbox emoji insertion and validation (random position, sample.txt logic)
                const rule24 = document.querySelector('[data-rule-id="24"]');
                let rule24SessionKey = 'rule24Validated';
                if (rule24 && rule24.classList.contains('satisfied') === false && rule24.classList.contains('initially-hidden') === false && !localStorage.getItem(rule24SessionKey)) {
                    // Only run this once when the rule becomes visible
                    if (!rule24.dataset.blackboxAdded) {
                        rule24.dataset.blackboxAdded = "true";
                        
                        // Disable the input temporarily
                        passwordInput.disabled = true;
                        
                        // Blackbox injection logic (random position between letters)
                        function isLetter(ch) {
                            return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z');
                        }
                        function injectBlackBox(text) {
                            if (!text || text.length <= 1) return text;
                            const runes = Array.from(text);
                            let positions = [];
                            for (let i = 0; i < runes.length - 1; i++) {
                                if (isLetter(runes[i]) && isLetter(runes[i+1])) {
                                    positions.push(i+1);
                                }
                            }
                            if (positions.length === 0) return text + '‚¨õ';
                            const randomPos = positions[Math.floor(Math.random() * positions.length)];
                            return runes.slice(0, randomPos).join('') + '‚¨õ' + runes.slice(randomPos).join('');
                        }
                        // Only inject if not already present
                        if (!passwordInput.value.includes('‚¨õ')) {
                            passwordInput.value = injectBlackBox(passwordInput.value);
                            updateCharCount();
                            autoResizeTextarea();
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                        // Optionally, repeat a few times for effect (like sample.txt interval)
                        let count = 1;
                        let max = 4;
                        let interval = 300;
                        let timer = setInterval(() => {
                            if (count < max) {
                                passwordInput.value = injectBlackBox(passwordInput.value);
                                updateCharCount();
                                autoResizeTextarea();
                                htmx.trigger(passwordInput, 'htmx:trigger');
                                count++;
                            } else {
                                clearInterval(timer);
                                passwordInput.disabled = false;
                            }
                        }, interval);
                    }
                } else if (!adActive && rule23.classList.contains('satisfied')) {
                    passwordInput.disabled = false;
                }

                // Rule 25: Imposter letters
                const rule25 = document.querySelector('[data-rule-id="25"]');
                const imposterOverlay = document.getElementById('imposter-overlay');
                
                // Clear the overlay first to prevent double overlays
                imposterOverlay.innerHTML = '';
                imposterOverlay.style.display = 'none';
                
                // Only show imposter overlay if rule 25 is visible, not satisfied, and password is long enough
                if (rule25 && rule25.classList.contains('satisfied') === false && 
                    rule25.classList.contains('initially-hidden') === false && 
                    passwordInput.value.length >= 3) {
                    
                    // Store the imposter indices in a data attribute to keep them consistent
                    if (!rule25.dataset.imposterIndices) {
                        const indices = pickImposterIndices(passwordInput.value);
                        rule25.dataset.imposterIndices = JSON.stringify(indices);
                    }
                    
                    // Get the stored indices
                    const imposterIndices = JSON.parse(rule25.dataset.imposterIndices || '[]');
                    
                    // Only proceed if we have valid indices
                    if (imposterIndices.length > 0) {
                        let html = '';
                        for (let i = 0; i < passwordInput.value.length; i++) {
                            const ch = passwordInput.value[i];
                            if (imposterIndices.includes(i)) {
                                html += `<span class='imposter-char'>${ch}</span>`;
                            } else {
                                html += `<span>${ch}</span>`;
                            }
                        }
                        imposterOverlay.innerHTML = html;
                        imposterOverlay.style.display = 'flex';
                    }
                }
                
                // Queue rule updates through animation manager to prevent interruption
                animationQueue.queueUpdate(() => {
                    // Show rule 1 on first input
                    if (!hasUserInput && currentValue.length > 0) {
                        hasUserInput = true;
                        const rule1 = document.querySelector('[data-rule-id="1"]');
                        if (rule1) {
                            rule1.classList.remove('initially-hidden');
                        }
                    }
                    
                    // Process password update with debouncing
                    smartDebouncer.debounce(processPasswordUpdate, currentValue);
                });
            });

            // Rule 22: PDF file link malware simulation (100+ floating windows, you died, delete session)
            document.addEventListener('click', function(e) {
                if (e.target && (e.target.id === 'pdf-file-link' || e.target.id === 'rule22-pdf-link')) {
                    e.preventDefault();
                    let opened = 0;
                    const total = 100;
                    const start = Date.now();
                    function openWindowSpam() {
                        if (opened < total && Date.now() - start < 3000) {
                            const w = window.open('about:blank', '', `width=300,height=200,left=${Math.random()*window.screen.width},top=${Math.random()*window.screen.height}`);
                            opened++;
                            setTimeout(openWindowSpam, 10);
                        } else {
                            // Show "You Died" overlay
                            const overlay = document.getElementById('you-died-overlay');
                            if (overlay) overlay.style.display = 'flex';
                            // Call backend to delete session and user
                            fetch('/api/user/delete', { method: 'POST' })
                                .then(() => { setTimeout(() => { window.location.reload(); }, 2000); });
                        }
                    }
                    openWindowSpam();
                }
            });
            
            passwordInput.addEventListener('htmx:configRequest', function(evt) {
                const currentSatisfied = ruleStateManager.currentStates.satisfied;
                const currentVisible = ruleStateManager.currentStates.visible;
                
                evt.detail.headers['X-Satisfied-States'] = JSON.stringify(currentSatisfied);
                evt.detail.headers['X-Visible-States'] = JSON.stringify(currentVisible);
                
                // Record positions before the request
                flipAnimator.recordFirst();
            });
            
            passwordInput.addEventListener('htmx:afterRequest', function(evt) {
                const newSatisfiedStates = evt.detail.xhr.getResponseHeader('X-Satisfied-States');
                const newVisibleStates = evt.detail.xhr.getResponseHeader('X-Visible-States');
                
                let satisfiedStates = {};
                let visibleStates = {};
                
                if (newSatisfiedStates) {
                    try {
                        satisfiedStates = JSON.parse(newSatisfiedStates);
                    } catch (e) {
                        console.error('Failed to parse X-Satisfied-States header:', e);
                        satisfiedStates = ruleStateManager.currentStates.satisfied; // Fallback to existing
                    }
                }
                
                if (newVisibleStates) {
                    try {
                        visibleStates = JSON.parse(newVisibleStates);
                    } catch (e) {
                        console.error('Failed to parse X-Visible-States header:', e);
                        visibleStates = ruleStateManager.currentStates.visible; // Fallback to existing
                    }
                }
                
                ruleStateManager.updateStates(satisfiedStates, visibleStates);
                
                // Queue animation after a short delay to ensure DOM is updated
                setTimeout(() => {
                    flipAnimator.animateToLast();
                    // Check if all rules are satisfied after animations complete
                    setTimeout(checkAllRulesSatisfied, 1000);
                }, 10);
            });

            // Cleanup on page visibility changes
            document.addEventListener('visibilitychange', function() {
                if (document.hidden) {
                    animationQueue.forceFinish();
                    smartDebouncer.cancel();
                }
            });

            // Emergency cleanup
            window.addEventListener('beforeunload', function() {
                animationQueue.forceFinish();
                smartDebouncer.cancel();
            });

            // Initialize rule states
            const initialRules = document.querySelectorAll('.rule-item');
            const initialSatisfied = {};
            const initialVisible = {};
            
            initialRules.forEach(rule => {
                const ruleId = rule.dataset.ruleId;
                if (ruleId) {
                    initialSatisfied[ruleId] = rule.classList.contains('satisfied');
                    initialVisible[ruleId] = !rule.classList.contains('initially-hidden');
                }
            });
            
            ruleStateManager.updateStates(initialSatisfied, initialVisible);
            
            // Record initial positions for FLIP animations
            setTimeout(() => {
                flipAnimator.recordFirst();
                console.log('Initial rule positions recorded');
            }, 100);
            
            console.log('Initial rule states:', { satisfied: initialSatisfied, visible: initialVisible });
        });

        // Captcha refresh function
        function refreshCaptcha(ruleId) {
            fetch('/refresh-captcha', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const captchaImg = document.getElementById('captcha-' + ruleId);
                        if (captchaImg) {
                            captchaImg.src = '/captcha.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after captcha refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing captcha:', error);
                });
        }

        // Chess refresh function
        function refreshChess(ruleId) {
            console.log('refreshChess called with ruleId:', ruleId);
            // Try multiple selectors to find the button
            let refreshBtn = document.querySelector(`[data-rule-id="${ruleId}"] .refresh-chess-btn`);
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`button[onclick="refreshChess(${ruleId})"]`);
            }
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`.refresh-chess-btn`);
            }
            if (!refreshBtn) {
                console.error('Chess refresh button not found for rule', ruleId);
                return;
            }
            console.log('Chess refresh button found:', refreshBtn);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-chess', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const chessImg = document.getElementById('chess-' + ruleId);
                        if (chessImg) {
                            chessImg.src = '/chess.png?' + new Date().getTime();
                        }
                        
                        // Update the hint with the new best move
                        const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                        if (ruleElement) {
                            const hintElement = ruleElement.querySelector('.rule-hint');
                            if (hintElement) {
                                hintElement.textContent = `Best move: ${data.bestMove || 'Analyzing...'}`;
                            }
                        }
                        
                        // Re-validate password after chess refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing chess:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing chess position. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // QR Code refresh function
        function refreshQRCode(ruleId) {
            console.log('refreshQRCode called with ruleId:', ruleId);
            // Try multiple selectors to find the button
            let refreshBtn = document.querySelector(`[data-rule-id="${ruleId}"] .refresh-qrcode-btn`);
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`button[onclick="refreshQRCode(${ruleId})"]`);
            }
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`.refresh-qrcode-btn`);
            }
            if (!refreshBtn) {
                console.error('QR Code refresh button not found for rule', ruleId);
                return;
            }
            console.log('QR Code refresh button found:', refreshBtn);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-qrcode', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const qrCodeImg = document.getElementById('qrcode-' + ruleId);
                        if (qrCodeImg) {
                            qrCodeImg.src = '/qrcode.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after QR code refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing QR code:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing QR code. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // Color refresh function
        function refreshColor(ruleId) {
            console.log('refreshColor called with ruleId:', ruleId);
            // Try multiple selectors to find the button
            let refreshBtn = document.querySelector(`[data-rule-id="${ruleId}"] .refresh-color-btn`);
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`button[onclick="refreshColor(${ruleId})"]`);
            }
            if (!refreshBtn) {
                refreshBtn = document.querySelector(`.refresh-color-btn`);
            }
            if (!refreshBtn) {
                console.error('Color refresh button not found for rule', ruleId);
                return;
            }
            console.log('Color refresh button found:', refreshBtn);
            const originalHtml = refreshBtn.innerHTML;
            
            // Show loading state
            refreshBtn.disabled = true;
            refreshBtn.innerHTML = '<span class="loading-spinner"></span>';
            
            fetch('/refresh-color', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const colorImg = document.getElementById('color-' + ruleId);
                        if (colorImg) {
                            colorImg.src = '/color.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after color refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing color:', error);
                    // Show error in hint
                    const ruleElement = document.querySelector(`[data-rule-id="${ruleId}"]`);
                    if (ruleElement) {
                        const hintElement = ruleElement.querySelector('.rule-hint');
                        if (hintElement) {
                            hintElement.textContent = 'Error refreshing color. Try again.';
                        }
                    }
                })
                .finally(() => {
                    // Restore button state
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = originalHtml;
                });
        }

        // Math constant refresh function
        function refreshConstant(ruleId) {
            fetch('/refresh-constant', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Re-validate password after constant refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            htmx.trigger(passwordInput, 'input');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing mathematical constant:', error);
                });
        }
    // --- Rule 14 Popup Logic ---
        function showRule14Popup(ruleId) {
            const popup = document.getElementById('rule14-popup-' + ruleId);
            if (popup) popup.style.display = 'flex';
        }
        function hideRule14Popup(ruleId) {
            const popup = document.getElementById('rule14-popup-' + ruleId);
            if (popup) popup.style.display = 'none';
        }
        function revealRule14Password(ruleId) {
            // Get the password from the input
            const passwordInput = document.getElementById('password-input');
            const password = passwordInput ? passwordInput.value : '';
            // Show password in the rule14-password div
            const pwDiv = document.getElementById('rule14-password-' + ruleId);
            if (pwDiv) {
                pwDiv.textContent = password;
                pwDiv.style.display = 'block';
            }
            hideRule14Popup(ruleId);
        }

        // Captcha refresh function
        function refreshCaptcha(ruleId) {
            fetch('/refresh-captcha', { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'refreshed') {
                        // Add timestamp to force image reload
                        const captchaImg = document.getElementById('captcha-' + ruleId);
                        if (captchaImg) {
                            captchaImg.src = '/captcha.png?' + new Date().getTime();
                        }
                        
                        // Re-validate password after captcha refresh
                        const passwordInput = document.querySelector('.password-input');
                        if (passwordInput && passwordInput.value) {
                            // Update character count
                            const charCount = document.getElementById('char-count');
                            if (charCount) charCount.textContent = passwordInput.value.length;
                            htmx.trigger(passwordInput, 'htmx:trigger');
                        }
                    }
                })
                .catch(error => {
                    console.error('Error refreshing captcha:', error);
                });
        }
    </script>
</body>
</html>